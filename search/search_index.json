{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"dd-dataverse-ingest \u00b6 Service for ingesting datasets into Dataverse via the API. Purpose \u00b6 This service takes directories containing data and metadata and creates datasets from them in a Dataverse installation via the Dataverse API. Interfaces \u00b6 The datasets are prepared as deposit directories (or \"deposits\" for short) in the ingest area. A deposit is a directory with the following structure: 087920d1-e37d-4263-84c7-1321e3ecb5f8 \u251c\u2500\u2500 bag \u2502 \u251c\u2500\u2500 bag-info.txt \u2502 \u251c\u2500\u2500 bagit.txt \u2502 \u251c\u2500\u2500 data \u2502 \u2502 \u251c\u2500\u2500 file1.txt \u2502 \u2502 \u251c\u2500\u2500 file2.txt \u2502 \u2502 \u2514\u2500\u2500 subdirectory \u2502 \u2502 \u2514\u2500\u2500 file3.txt \u2502 \u251c\u2500\u2500 dataset.yml \u2502 \u2514\u2500\u2500 manifest-sha1.txt \u2514\u2500\u2500 deposit.properties The name of the deposit directory must be a UUID. The deposit directory contains the following files: File Description deposit.properties Contains instructions for dd-dataverse-ingest on how to ingest the dataset. bag/ A bag, i.e. a directory with the files to be ingested, laid out according to the BagIt specification. The name of the bag does not have to be \"bag\"; it may be any valid filename. Instead of one bag multiple bags may be included, see below . Metadata and instructions \u00b6 In the root of the bag, the following files can be included to provide metadata and instructions for the ingest process. The files are in YAML format and closely follow the JSON that is passed to the Dataverse API. File Description init.yml Preconditions and instructions for creating a new dataset. dataset.yml Dataset level metadata. edit-permissions.yml Role assignments to create or delete on the dataset edit-files.yml Instructions for deleting, replacing or moving files, or updating the file metadata; also included: restricting and embargoing files edit-metadata.yml Edit dataset level metadata, including metadata value deletions update-state.yml Whether to publish the dataset version or submit it for review init.yml \u00b6 The init file initializes the ingest process. It can be used to verify that an expected precondition is met: init: expect: state: 'released' # or 'draft' dataverseRoleAssignment: assignee: '@myuser' role: ':autenticated-user' datasetRoleAssignment: assignee: '@myuser' role: 'contributor' If the state of the dataset does not match the expected state, the ingest procedure will be aborted and the deposit will be put in the FAILED state. The expected state can be either released or draft . By default, no check will be performed. If the role assignment in dataverseRoleAssignment does not exist on the target dataverse collection (currently always root ) the ingest procedure will be aborted putting the deposit in a REJECTED state. The same happens if the role assignment in datasetRoleAssignment does not exist on the target dataset (only applicable to update-deposits). Note the difference in the resulting deposit state when expectations are not met. The rationale is that an unexpected dataset state is likely an error by the service or Dataverse and the expected role assignments are a kind of authorization check. The init.yml file can also be used to instruct the service to import the bag as a dataset with an existing DOI: init: create: importPid: 'doi:10.5072/FK2/ABCDEF' In this case the updates-dataset property in deposit.properties should not be set. It will be ignored if it is. By default, a new dataset will be created, whose persistent identifier will be assigned by Dataverse. The user is responsible for providing expectations and instructions that do not conflict with each other. For example, if the importPid property is set, and the state property is set to released , the service will either abort because the dataset already exists, or it will fail to import the dataset, because the dataset already exists. dataset.yml \u00b6 The format is the same as the JSON that is passed to the createDataset endpoint of the Dataverse API. Note that the files field is not used. It will be set to the empty list by the service, because otherwise Dataverse will reject the request. datasetVersion: license: name: \"CC0 1.0\" uri: \"http://creativecommons.org/publicdomain/zero/1.0\" fileAccessRequest: true metadataBlocks: citation: displayName: \"Citation Metadata\" name: \"citation\" fields: - typeName: \"title\" multiple: false typeClass: \"primitive\" value: \"My dataset\" # Add more metadata fields and blocks as needed edit-permissions.yml \u00b6 editPermissions: deleteRoleAssignments: - role: 'admin' assignee: '@user1' addRoleAssignments: - role: 'admin' assignee: '@user2' Allows you to selectively delete or add role assignments on the dataset. The format is the same as the JSON that is passed to the assignNewRole and deleteRoleAssignments endpoints of the Dataverse API. edit-files.yml \u00b6 See the inline comments for more information. The steps are performed in the order here given. You cannot change the order of the steps by changing the order of the items in the file. The actions specified in this file correspond roughly to the actions available in the dropdown menu in the file view of a dataset in Dataverse. updateFileMetas contains items in the format of the JSON that is passed to the updateFileMetadata endpoint of the Dataverse API. editFiles: # Deletes the files from the dataset. The files are looked up by their path in the dataset. Note, that it is possible to add files back to the same location # in the dataset in the same deposit. In that case, there will be no continuous history of the file in the dataset. deleteFiles: - 'file1.txt' - 'subdirectory/file3.txt' # Replaces the files in the dataset. The files are looked up by their path in the dataset. The replacement file is looked up in the bag, under the `data` # directory under the same path as the original file has in the dataset. Note that files in `replaceFiles` will automatically be skipped in the add files step, replaceFiles: - 'file2.txt' # Adds files to the dataset and makes them unrestricted. The files are processed in batches, meaning they are uploaded as ZIP files to Dataverse, for Dataverse # to unzip them. This is more efficient than adding the files one by one. addUnrestrictedFiles: - 'file6.txt' # Adds files to the dataset and makes them restricted. The files are processed in batches, meaning they are uploaded as ZIP files to Dataverse, for Dataverse # to unzip them. This is more efficient than adding the files one by one. addRestrictedFiles: - 'file4.txt' - 'subdirectory/file5.txt' # Adds files to the dataset and makes them unrestricted. The files are processed in batches, but separately, so that these files are not uploaded together # with files from addUnrestrictedFiles. This is useful if you need to circumvent special processing by Dataverse, such as re-zipping Shapefile projects. # See: https://guides.dataverse.org/en/6.3/developers/geospatial.html#geospatial-data addUnrestrictedFilesSeparately: - 'bicycles.shp' - 'cars.shp' # Adds files to the dataset and makes them restricted. The files are processed in batches, but separately, so that these files are not uploaded together # with files from addRestrictedFiles. This is useful if you need to circumvent special processing by Dataverse, such as re-zipping Shapefile projects. # See: https://guides.dataverse.org/en/6.3/developers/geospatial.html#geospatial-data addRestrictedFilesSeparately: - 'bicycles.shp' - 'cars.shp' # Adds files to the dataset and makes them unrestricted. The files are processed one by one, meaning they are uploaded as individual files to Dataverse. This is # useful if you need to make sure that ZIP files are expanded by Dataverse, for example because you want to make sure the special processing for Shapefiles is # applied. addUnrestrictedFilesIndividually: - 'bicycles.zip' # The same as above, but the files are added restricted. addRestrictedFilesIndividually: - 'bicycles.zip' # Moves files in the dataset. This is essentially a metadata change: the label and/or directoryLabel of the file is changed. moveFiles: - from: 'file6.txt' # Old location in the dataset to: 'subdirectory/file6.txt' # New location in the dataset # Updates the metadata of the files in the dataset. The files are looked up by their path in the dataset, so it is not possible to change the label or # directoryLabel of the file in this step; use moveFiles for that. updateFileMetas: - description: \"This is the first file\" label: \"file1.txt\" directoryLabel: \"subdirectory\" restricted: false categories: [ 'Testlabel' ] # Sets one or more embargoes on the files in the dataset. addEmbargoes: - filePaths: [ 'file1.txt' ] # All other files will NOT be embargoed dateAvailable: '2030-01-01' reason: 'Pending publication' # This is not a separate step, but the auto-renaming takes place whenever a local filepath is translated to a dataset filepath. autoRenameFiles: - from: \"Unsanitize'd/file?\" # Local file name to: \"Sanitize_d/file_\" # The file name assigned in the dataset edit-metadata.yml \u00b6 editMetadata: addFieldValues: - typeName: \"subject\" typeClass: \"controlledVocabulary\" multiple: true value: - 'Astronomy and Astrophysics' replaceFieldValues: - typeName: \"producer\" typeClass: \"compound\" multiple: true value: - producerName: typeName: \"producerName\" value: \"John Doe\" - producerAffiliation: typeName: \"producerAffiliation\" value: \"University of Somewhere\" deleteFieldValues: - typeName: \"subject\" typeClass: \"controlledVocabulary\" multiple: true value: - 'Astronomy and Astrophysics' Allows you to selectively delete, add or replace metadata field values. The format is the based on the JSON that is passed to the editDatasetMetadata and deleteDatasetMetadata endpoints of the Dataverse API. However, unlike in the JSON accepted by Dataverse, the typeClass and `multiple fields are not optional in the YAML file. This is due to the library used to parse the YAML files, which uses a deserializer that was designed to parse the JSON that is returned by the Dataverse API (which does not include these fields). The only difference between addFieldValues and replaceFieldValues is that the latter will pass the replace=true parameter to the API. See the API documentation for the exact behavior. Unlike in the editing of files, deletion of field values takes place at the end of the process, so that we don't create a situation where a required field is temporarily empty and Dataverse refuses to save the metadata. update-state.yml \u00b6 updateState: publish: major # or 'minor' updateState: releaseMigrated: 2021-01-01 New versions of existing datasets \u00b6 A deposit can also be used to create a new version of an existing dataset. In this case, the deposit.properties file must contain the following property: updates-dataset: 'doi:10.5072/FK2/ABCDEF' in which the value is the DOI of the dataset to be updated. Instead of one bag directory, the deposit may contain multiple bags. In this case the directories are processed in lexicographical order, so you should name the bags accordingly, e.g. 1-bag , 2-bag , 3-bag , etc. , or 001-bag , 002-bag , 003-bag , etc., depending on the number of bags. DANS bag \u00b6 A DANS bag is a directory in the BagIt format, that also conforms to the DANS bag profile . This is a legacy format that is used by the DANS SWORD2 service. The service can convert a DANS deposit to the standard one described above. Processing \u00b6 The deposit area is a directory with the following structure: imports \u251c\u2500\u2500 inbox \u2502 \u2514\u2500\u2500 path \u2502 \u2514\u2500\u2500 to \u2502 \u251c\u2500\u2500 batch1 \u2502 \u2502 \u251c\u2500\u2500 0223914e-c053-4ee8-99d8-a9135fa4db4a \u2502 \u2502 \u251c\u2500\u2500 1b5c1b24-de40-4a40-9c58-d4409672229e \u2502 \u2502 \u2514\u2500\u2500 9a47c5be-58c0-4295-8409-8156bd9ed9e1 \u2502 \u2514\u2500\u2500 batch2 \u2502 \u251c\u2500\u2500 5e42a936-4b90-4cac-b3c1-798b0b5eeb0b \u2502 \u2514\u2500\u2500 9c2ce5a5-b836-468a-89d4-880efb071d9d \u2514\u2500\u2500 outbox \u2514\u2500\u2500 path \u2514\u2500\u2500 to \u2514\u2500\u2500 batch1 \u251c\u2500\u2500 failed \u251c\u2500\u2500 processed \u2502 \u2514\u2500\u2500 7660539b-6ddb-4719-aa31-a3d1c978081b \u2514\u2500\u2500 rejected Processing a batch \u00b6 The deposits to be processed are to be placed under inbox . All the files in it must be readable and writable by the service. When the service is requested to process a batch, it will do the following: Sort the deposits in the batch by their creation.timestamp property in deposit.properties , in ascending order. Process each deposit in the batch in order. Processing a deposit \u00b6 Sort the bags in the deposit by lexicographical order. Process each bag in the deposit in order. Move the deposit to: outbox/path/to/batch/processed if the all versions were published successfully, or to outbox/path/to/batch/rejected if one or more of the versions were not valid, or to outbox/path/to/batch/failed if some other error occurred. Note that the relative path of the processed deposits in outbox is the same as in the inbox, except for an extra level of directories for the status of the deposit. Processing a bag \u00b6 The actions described in the Yaml files will be executed in same order as they are listed above. Note that changing the order of the actions in the Yaml files has no effect on the order in which they are executed. All files and all action fields (e.g., addRestrictedFiles ) are optional, except for dataset.yml , when creating a new dataset. The task log \u00b6 The service keeps the progress of the processing in file called _tasks.yml . Its layout corresponds closely to the combined layout of the instruction Yaml files. (The underscore in the name is there to make it stand out in the directory listing.): taskLog: init: targetPid: null expect: state: completed: false dataverseRoleAssignment: completed: false datasetRoleAssignment: completed: false create: completed: false dataset: completed: false editPermissions: deleteRoleAssignments: completed: false numberCompleted: 0 addRoleAssignments: completed: false numberCompleted: 0 editFiles: deleteFiles: completed: false replaceFiles: completed: false numberCompleted: 0 addUnrestrictedFiles: completed: false numberCompleted: 0 addRestrictedFiles: completed: false numberCompleted: 0 addUnrestrictedIndividually: completed: false numberCompleted: 0 addRestrictedIndividually: completed: false numberCompleted: 0 moveFiles: completed: false updateFileMetas: completed: false addEmbargoes: completed: false numberCompleted: 0 editMetadata: addFieldValues: completed: false replaceFieldValues: completed: false deleteFieldValues: completed: false updateState: completed: false The file is updated in memory and will be written to the root of the bag when the processing of the bag is finished or fails. If at the start of processing the bag the file is found in the root of the bag, the service will continue from where it left off. Note, that some items have a numberCompleted field, so if the overall task is not yet completed, the service will continue from where it left off. If you want to re-ingest a deposit completely, delete the _tasks.yml file from the root of the deposit. You should probably also delete the dataset version that was created in the previous run.","title":"Description"},{"location":"#dd-dataverse-ingest","text":"Service for ingesting datasets into Dataverse via the API.","title":"dd-dataverse-ingest"},{"location":"#purpose","text":"This service takes directories containing data and metadata and creates datasets from them in a Dataverse installation via the Dataverse API.","title":"Purpose"},{"location":"#interfaces","text":"The datasets are prepared as deposit directories (or \"deposits\" for short) in the ingest area. A deposit is a directory with the following structure: 087920d1-e37d-4263-84c7-1321e3ecb5f8 \u251c\u2500\u2500 bag \u2502 \u251c\u2500\u2500 bag-info.txt \u2502 \u251c\u2500\u2500 bagit.txt \u2502 \u251c\u2500\u2500 data \u2502 \u2502 \u251c\u2500\u2500 file1.txt \u2502 \u2502 \u251c\u2500\u2500 file2.txt \u2502 \u2502 \u2514\u2500\u2500 subdirectory \u2502 \u2502 \u2514\u2500\u2500 file3.txt \u2502 \u251c\u2500\u2500 dataset.yml \u2502 \u2514\u2500\u2500 manifest-sha1.txt \u2514\u2500\u2500 deposit.properties The name of the deposit directory must be a UUID. The deposit directory contains the following files: File Description deposit.properties Contains instructions for dd-dataverse-ingest on how to ingest the dataset. bag/ A bag, i.e. a directory with the files to be ingested, laid out according to the BagIt specification. The name of the bag does not have to be \"bag\"; it may be any valid filename. Instead of one bag multiple bags may be included, see below .","title":"Interfaces"},{"location":"#metadata-and-instructions","text":"In the root of the bag, the following files can be included to provide metadata and instructions for the ingest process. The files are in YAML format and closely follow the JSON that is passed to the Dataverse API. File Description init.yml Preconditions and instructions for creating a new dataset. dataset.yml Dataset level metadata. edit-permissions.yml Role assignments to create or delete on the dataset edit-files.yml Instructions for deleting, replacing or moving files, or updating the file metadata; also included: restricting and embargoing files edit-metadata.yml Edit dataset level metadata, including metadata value deletions update-state.yml Whether to publish the dataset version or submit it for review","title":"Metadata and instructions"},{"location":"#inityml","text":"The init file initializes the ingest process. It can be used to verify that an expected precondition is met: init: expect: state: 'released' # or 'draft' dataverseRoleAssignment: assignee: '@myuser' role: ':autenticated-user' datasetRoleAssignment: assignee: '@myuser' role: 'contributor' If the state of the dataset does not match the expected state, the ingest procedure will be aborted and the deposit will be put in the FAILED state. The expected state can be either released or draft . By default, no check will be performed. If the role assignment in dataverseRoleAssignment does not exist on the target dataverse collection (currently always root ) the ingest procedure will be aborted putting the deposit in a REJECTED state. The same happens if the role assignment in datasetRoleAssignment does not exist on the target dataset (only applicable to update-deposits). Note the difference in the resulting deposit state when expectations are not met. The rationale is that an unexpected dataset state is likely an error by the service or Dataverse and the expected role assignments are a kind of authorization check. The init.yml file can also be used to instruct the service to import the bag as a dataset with an existing DOI: init: create: importPid: 'doi:10.5072/FK2/ABCDEF' In this case the updates-dataset property in deposit.properties should not be set. It will be ignored if it is. By default, a new dataset will be created, whose persistent identifier will be assigned by Dataverse. The user is responsible for providing expectations and instructions that do not conflict with each other. For example, if the importPid property is set, and the state property is set to released , the service will either abort because the dataset already exists, or it will fail to import the dataset, because the dataset already exists.","title":"init.yml"},{"location":"#datasetyml","text":"The format is the same as the JSON that is passed to the createDataset endpoint of the Dataverse API. Note that the files field is not used. It will be set to the empty list by the service, because otherwise Dataverse will reject the request. datasetVersion: license: name: \"CC0 1.0\" uri: \"http://creativecommons.org/publicdomain/zero/1.0\" fileAccessRequest: true metadataBlocks: citation: displayName: \"Citation Metadata\" name: \"citation\" fields: - typeName: \"title\" multiple: false typeClass: \"primitive\" value: \"My dataset\" # Add more metadata fields and blocks as needed","title":"dataset.yml"},{"location":"#edit-permissionsyml","text":"editPermissions: deleteRoleAssignments: - role: 'admin' assignee: '@user1' addRoleAssignments: - role: 'admin' assignee: '@user2' Allows you to selectively delete or add role assignments on the dataset. The format is the same as the JSON that is passed to the assignNewRole and deleteRoleAssignments endpoints of the Dataverse API.","title":"edit-permissions.yml"},{"location":"#edit-filesyml","text":"See the inline comments for more information. The steps are performed in the order here given. You cannot change the order of the steps by changing the order of the items in the file. The actions specified in this file correspond roughly to the actions available in the dropdown menu in the file view of a dataset in Dataverse. updateFileMetas contains items in the format of the JSON that is passed to the updateFileMetadata endpoint of the Dataverse API. editFiles: # Deletes the files from the dataset. The files are looked up by their path in the dataset. Note, that it is possible to add files back to the same location # in the dataset in the same deposit. In that case, there will be no continuous history of the file in the dataset. deleteFiles: - 'file1.txt' - 'subdirectory/file3.txt' # Replaces the files in the dataset. The files are looked up by their path in the dataset. The replacement file is looked up in the bag, under the `data` # directory under the same path as the original file has in the dataset. Note that files in `replaceFiles` will automatically be skipped in the add files step, replaceFiles: - 'file2.txt' # Adds files to the dataset and makes them unrestricted. The files are processed in batches, meaning they are uploaded as ZIP files to Dataverse, for Dataverse # to unzip them. This is more efficient than adding the files one by one. addUnrestrictedFiles: - 'file6.txt' # Adds files to the dataset and makes them restricted. The files are processed in batches, meaning they are uploaded as ZIP files to Dataverse, for Dataverse # to unzip them. This is more efficient than adding the files one by one. addRestrictedFiles: - 'file4.txt' - 'subdirectory/file5.txt' # Adds files to the dataset and makes them unrestricted. The files are processed in batches, but separately, so that these files are not uploaded together # with files from addUnrestrictedFiles. This is useful if you need to circumvent special processing by Dataverse, such as re-zipping Shapefile projects. # See: https://guides.dataverse.org/en/6.3/developers/geospatial.html#geospatial-data addUnrestrictedFilesSeparately: - 'bicycles.shp' - 'cars.shp' # Adds files to the dataset and makes them restricted. The files are processed in batches, but separately, so that these files are not uploaded together # with files from addRestrictedFiles. This is useful if you need to circumvent special processing by Dataverse, such as re-zipping Shapefile projects. # See: https://guides.dataverse.org/en/6.3/developers/geospatial.html#geospatial-data addRestrictedFilesSeparately: - 'bicycles.shp' - 'cars.shp' # Adds files to the dataset and makes them unrestricted. The files are processed one by one, meaning they are uploaded as individual files to Dataverse. This is # useful if you need to make sure that ZIP files are expanded by Dataverse, for example because you want to make sure the special processing for Shapefiles is # applied. addUnrestrictedFilesIndividually: - 'bicycles.zip' # The same as above, but the files are added restricted. addRestrictedFilesIndividually: - 'bicycles.zip' # Moves files in the dataset. This is essentially a metadata change: the label and/or directoryLabel of the file is changed. moveFiles: - from: 'file6.txt' # Old location in the dataset to: 'subdirectory/file6.txt' # New location in the dataset # Updates the metadata of the files in the dataset. The files are looked up by their path in the dataset, so it is not possible to change the label or # directoryLabel of the file in this step; use moveFiles for that. updateFileMetas: - description: \"This is the first file\" label: \"file1.txt\" directoryLabel: \"subdirectory\" restricted: false categories: [ 'Testlabel' ] # Sets one or more embargoes on the files in the dataset. addEmbargoes: - filePaths: [ 'file1.txt' ] # All other files will NOT be embargoed dateAvailable: '2030-01-01' reason: 'Pending publication' # This is not a separate step, but the auto-renaming takes place whenever a local filepath is translated to a dataset filepath. autoRenameFiles: - from: \"Unsanitize'd/file?\" # Local file name to: \"Sanitize_d/file_\" # The file name assigned in the dataset","title":"edit-files.yml"},{"location":"#edit-metadatayml","text":"editMetadata: addFieldValues: - typeName: \"subject\" typeClass: \"controlledVocabulary\" multiple: true value: - 'Astronomy and Astrophysics' replaceFieldValues: - typeName: \"producer\" typeClass: \"compound\" multiple: true value: - producerName: typeName: \"producerName\" value: \"John Doe\" - producerAffiliation: typeName: \"producerAffiliation\" value: \"University of Somewhere\" deleteFieldValues: - typeName: \"subject\" typeClass: \"controlledVocabulary\" multiple: true value: - 'Astronomy and Astrophysics' Allows you to selectively delete, add or replace metadata field values. The format is the based on the JSON that is passed to the editDatasetMetadata and deleteDatasetMetadata endpoints of the Dataverse API. However, unlike in the JSON accepted by Dataverse, the typeClass and `multiple fields are not optional in the YAML file. This is due to the library used to parse the YAML files, which uses a deserializer that was designed to parse the JSON that is returned by the Dataverse API (which does not include these fields). The only difference between addFieldValues and replaceFieldValues is that the latter will pass the replace=true parameter to the API. See the API documentation for the exact behavior. Unlike in the editing of files, deletion of field values takes place at the end of the process, so that we don't create a situation where a required field is temporarily empty and Dataverse refuses to save the metadata.","title":"edit-metadata.yml"},{"location":"#update-stateyml","text":"updateState: publish: major # or 'minor' updateState: releaseMigrated: 2021-01-01","title":"update-state.yml"},{"location":"#new-versions-of-existing-datasets","text":"A deposit can also be used to create a new version of an existing dataset. In this case, the deposit.properties file must contain the following property: updates-dataset: 'doi:10.5072/FK2/ABCDEF' in which the value is the DOI of the dataset to be updated. Instead of one bag directory, the deposit may contain multiple bags. In this case the directories are processed in lexicographical order, so you should name the bags accordingly, e.g. 1-bag , 2-bag , 3-bag , etc. , or 001-bag , 002-bag , 003-bag , etc., depending on the number of bags.","title":"New versions of existing datasets"},{"location":"#dans-bag","text":"A DANS bag is a directory in the BagIt format, that also conforms to the DANS bag profile . This is a legacy format that is used by the DANS SWORD2 service. The service can convert a DANS deposit to the standard one described above.","title":"DANS bag"},{"location":"#processing","text":"The deposit area is a directory with the following structure: imports \u251c\u2500\u2500 inbox \u2502 \u2514\u2500\u2500 path \u2502 \u2514\u2500\u2500 to \u2502 \u251c\u2500\u2500 batch1 \u2502 \u2502 \u251c\u2500\u2500 0223914e-c053-4ee8-99d8-a9135fa4db4a \u2502 \u2502 \u251c\u2500\u2500 1b5c1b24-de40-4a40-9c58-d4409672229e \u2502 \u2502 \u2514\u2500\u2500 9a47c5be-58c0-4295-8409-8156bd9ed9e1 \u2502 \u2514\u2500\u2500 batch2 \u2502 \u251c\u2500\u2500 5e42a936-4b90-4cac-b3c1-798b0b5eeb0b \u2502 \u2514\u2500\u2500 9c2ce5a5-b836-468a-89d4-880efb071d9d \u2514\u2500\u2500 outbox \u2514\u2500\u2500 path \u2514\u2500\u2500 to \u2514\u2500\u2500 batch1 \u251c\u2500\u2500 failed \u251c\u2500\u2500 processed \u2502 \u2514\u2500\u2500 7660539b-6ddb-4719-aa31-a3d1c978081b \u2514\u2500\u2500 rejected","title":"Processing"},{"location":"#processing-a-batch","text":"The deposits to be processed are to be placed under inbox . All the files in it must be readable and writable by the service. When the service is requested to process a batch, it will do the following: Sort the deposits in the batch by their creation.timestamp property in deposit.properties , in ascending order. Process each deposit in the batch in order.","title":"Processing a batch"},{"location":"#processing-a-deposit","text":"Sort the bags in the deposit by lexicographical order. Process each bag in the deposit in order. Move the deposit to: outbox/path/to/batch/processed if the all versions were published successfully, or to outbox/path/to/batch/rejected if one or more of the versions were not valid, or to outbox/path/to/batch/failed if some other error occurred. Note that the relative path of the processed deposits in outbox is the same as in the inbox, except for an extra level of directories for the status of the deposit.","title":"Processing a deposit"},{"location":"#processing-a-bag","text":"The actions described in the Yaml files will be executed in same order as they are listed above. Note that changing the order of the actions in the Yaml files has no effect on the order in which they are executed. All files and all action fields (e.g., addRestrictedFiles ) are optional, except for dataset.yml , when creating a new dataset.","title":"Processing a bag"},{"location":"#the-task-log","text":"The service keeps the progress of the processing in file called _tasks.yml . Its layout corresponds closely to the combined layout of the instruction Yaml files. (The underscore in the name is there to make it stand out in the directory listing.): taskLog: init: targetPid: null expect: state: completed: false dataverseRoleAssignment: completed: false datasetRoleAssignment: completed: false create: completed: false dataset: completed: false editPermissions: deleteRoleAssignments: completed: false numberCompleted: 0 addRoleAssignments: completed: false numberCompleted: 0 editFiles: deleteFiles: completed: false replaceFiles: completed: false numberCompleted: 0 addUnrestrictedFiles: completed: false numberCompleted: 0 addRestrictedFiles: completed: false numberCompleted: 0 addUnrestrictedIndividually: completed: false numberCompleted: 0 addRestrictedIndividually: completed: false numberCompleted: 0 moveFiles: completed: false updateFileMetas: completed: false addEmbargoes: completed: false numberCompleted: 0 editMetadata: addFieldValues: completed: false replaceFieldValues: completed: false deleteFieldValues: completed: false updateState: completed: false The file is updated in memory and will be written to the root of the bag when the processing of the bag is finished or fails. If at the start of processing the bag the file is found in the root of the bag, the service will continue from where it left off. Note, that some items have a numberCompleted field, so if the overall task is not yet completed, the service will continue from where it left off. If you want to re-ingest a deposit completely, delete the _tasks.yml file from the root of the deposit. You should probably also delete the dataset version that was created in the previous run.","title":"The task log"},{"location":"config/","text":"Configuration \u00b6 This module can be configured by editing the configuration file. This file is installed in /etc/opt/dans.knaw.nl/dd-dataverse-ingest/config.yml when using the RPM. The settings are explained with comments in the file itself. An on-line version of the latest configuration file can be found here .","title":"Configuration"},{"location":"config/#configuration","text":"This module can be configured by editing the configuration file. This file is installed in /etc/opt/dans.knaw.nl/dd-dataverse-ingest/config.yml when using the RPM. The settings are explained with comments in the file itself. An on-line version of the latest configuration file can be found here .","title":"Configuration"},{"location":"context/","text":"Context \u00b6 This module is a component in the DANS Data Station Architecture .","title":"Context"},{"location":"context/#context","text":"This module is a component in the DANS Data Station Architecture .","title":"Context"},{"location":"dev-debugging/","text":"Local debugging \u00b6 To locally debug you need to have the following services running: A dataverse instance. Internal DANS developers can use the vagrant boxes with development versions of the Data Stations for this. You will need to configure access to the admin interface to use the unblock-key: curl -X PUT -d s3kretKey http://localhost:8080/api/admin/settings/:BlockedApiKey curl -X PUT -d unblock-key http://localhost:8080/api/admin/settings/:BlockedApiPolicy # When done debugging, you can reset the policy to localhost-only: curl -X PUT -d localhost-only \\ http://localhost:8080/api/admin/settings/:BlockedApiPolicy/?unblock-key=s3kretKey dd-validate-dans-bag . Note that its validation.baseFolder configuration property should point to the deposit area or an ancestor of it. Calling dd-dataverse-ingest is most conveniently done through the dd-dataverse-ingest-cli command line tool.","title":"Local debugging"},{"location":"dev-debugging/#local-debugging","text":"To locally debug you need to have the following services running: A dataverse instance. Internal DANS developers can use the vagrant boxes with development versions of the Data Stations for this. You will need to configure access to the admin interface to use the unblock-key: curl -X PUT -d s3kretKey http://localhost:8080/api/admin/settings/:BlockedApiKey curl -X PUT -d unblock-key http://localhost:8080/api/admin/settings/:BlockedApiPolicy # When done debugging, you can reset the policy to localhost-only: curl -X PUT -d localhost-only \\ http://localhost:8080/api/admin/settings/:BlockedApiPolicy/?unblock-key=s3kretKey dd-validate-dans-bag . Note that its validation.baseFolder configuration property should point to the deposit area or an ancestor of it. Calling dd-dataverse-ingest is most conveniently done through the dd-dataverse-ingest-cli command line tool.","title":"Local debugging"},{"location":"dev/","text":"Development \u00b6 General information about developing DANS modules can be found here .","title":"Overview"},{"location":"dev/#development","text":"General information about developing DANS modules can be found here .","title":"Development"},{"location":"installation/","text":"Installation \u00b6 Currently, this project is built as an RPM package for RHEL8 and later. The RPM will install the binaries to /opt/dans.knaw.nl/dd-dataverse-ingest and the configuration files to /etc/opt/dans.knaw.nl/dd-dataverse-ingest . For installation on systems that do no support RPM and/or systemd: Build the tarball (see next section). Extract it to some location on your system, for example /opt/dans.knaw.nl/dd-dataverse-ingest . Start the service with the following command /opt/dans.knaw.nl/dd-dataverse-ingest/bin/dd-dataverse-ingest server /opt/dans.knaw.nl/dd-dataverse-ingest/cfg/config.yml Building from source \u00b6 Prerequisites: Java 17 or higher Maven 3.3.3 or higher RPM (optional, only if you want to build the RPM package) Steps: git clone https://github.com/DANS-KNAW/dd-dataverse-ingest.git cd dd-dataverse-ingest mvn clean install If the rpm executable is found at /usr/local/bin/rpm , the build profile that includes the RPM packaging will be activated. If rpm is available, but at a different path, then activate it by using Maven's -P switch: mvn -Pprm install . Alternatively, to build the tarball execute: mvn clean install assembly:single","title":"Installation"},{"location":"installation/#installation","text":"Currently, this project is built as an RPM package for RHEL8 and later. The RPM will install the binaries to /opt/dans.knaw.nl/dd-dataverse-ingest and the configuration files to /etc/opt/dans.knaw.nl/dd-dataverse-ingest . For installation on systems that do no support RPM and/or systemd: Build the tarball (see next section). Extract it to some location on your system, for example /opt/dans.knaw.nl/dd-dataverse-ingest . Start the service with the following command /opt/dans.knaw.nl/dd-dataverse-ingest/bin/dd-dataverse-ingest server /opt/dans.knaw.nl/dd-dataverse-ingest/cfg/config.yml","title":"Installation"},{"location":"installation/#building-from-source","text":"Prerequisites: Java 17 or higher Maven 3.3.3 or higher RPM (optional, only if you want to build the RPM package) Steps: git clone https://github.com/DANS-KNAW/dd-dataverse-ingest.git cd dd-dataverse-ingest mvn clean install If the rpm executable is found at /usr/local/bin/rpm , the build profile that includes the RPM packaging will be activated. If rpm is available, but at a different path, then activate it by using Maven's -P switch: mvn -Pprm install . Alternatively, to build the tarball execute: mvn clean install assembly:single","title":"Building from source"},{"location":"to-api/","text":"The API is defined in dd-dataverse-ingest-api . The version implemented by this service can be viewed in Swagger UI in a new tab: API .","title":"API"}]}